import os
import uuid
import zlib
import struct
import pathlib
import argparse
import cryptography.hazmat.backends as backends
import cryptography.hazmat.primitives.ciphers as ciphers

'''
Format  C Type  Python type     Standard size   Notes
x   pad byte    no value
c   char    bytes of length 1   1
b   signed char     integer     1   (1),(3)
B   unsigned char   integer     1   (3)
?   _Bool   bool    1   (1)
h   short   integer     2   (3)
H   unsigned short  integer     2   (3)
i   int     integer     4   (3)
I   unsigned int    integer     4   (3)
l   long    integer     4   (3)
L   unsigned long   integer     4   (3)
q   long long   integer     8   (2), (3)
Q   unsigned long long  integer     8   (2), (3)
n   ssize_t     integer         (4)
N   size_t  integer         (4)
e   (7)     float   2   (5)
f   float   float   4   (5)
d   double  float   8   (5)
s   char[]  bytes
p   char[]  bytes
P   void *  integer         (6)
'''
I_SZ = struct.calcsize('I')
d_SZ = struct.calcsize('d')
IV_SZ = 16
KEY_SZ = 16
UID_SZ = 16
BACKEND = backends.default_backend()

class Cipher:

    @staticmethod
    def read(data):
        oft = 0
        secrets = data[oft:oft+IV_SZ+KEY_SZ]
        oft += IV_SZ+KEY_SZ
        byte_list = list(secrets)
        byte_list.reverse()
        iv_key = bytes(byte_list)
        return Cipher(iv_key[0:IV_SZ], iv_key[IV_SZ:IV_SZ+KEY_SZ]), oft

    def __init__(self, iv, key):
        self._iv = iv
        self._key = key
        self._cipher = ciphers.Cipher(ciphers.algorithms.AES(self._key),
                                      ciphers.modes.CBC(self._iv),
                                      backend=BACKEND)

    def __str__(self):
        return f"[{self._iv.hex()}|{self._key.hex()}]"

    def decrypt(self, data):
        decryptor = self._cipher.decryptor()
        return decryptor.update(data) + decryptor.finalize()

def unpad(data):
    sz = data[-1]
    return data[:-sz]

class Shuffler:
    '''Shuffles a file
    '''
    BS = 128
    CRYPT_BS = 16

    @staticmethod
    def read(data):
        oft = 0
        uid = uuid.UUID(bytes=data[oft:oft+UID_SZ])
        oft += UID_SZ
        cipher, cipher_sz = Cipher.read(data[oft:])
        oft += cipher_sz
        shuffle_map_sz, = struct.unpack('I', data[oft:oft+I_SZ])
        oft += I_SZ
        unshuffle_map = {}
        for _ in range(shuffle_map_sz):
            src_idx, dst_idx = struct.unpack('2I', data[oft:oft+2*I_SZ])
            oft += 2*I_SZ
            unshuffle_map[dst_idx] = src_idx
        return Shuffler(uid, cipher, unshuffle_map), oft

    def __init__(self, uid, cipher, unshuffle_map):
        self._uid = uid
        self._cipher = cipher
        self._unshuffle_map = unshuffle_map

    def __str__(self):
        return f"[{self._uid}|{self._cipher}]"

    @property
    def uid(self):
        return self._uid

    def unshuffle(self, data):
        # unshuffle blocks
        bcnt = len(data) // Shuffler.BS
        blocks = [data[k*Shuffler.BS:(k+1)*Shuffler.BS] for k in range(bcnt)]
        encrypted = b''
        for k in range(bcnt):
            encrypted += blocks[self._unshuffle_map[k]]
        # remove padding + decrypt + unpad
        compressed = self._cipher.decrypt(unpad(encrypted))
        if not compressed:
            return b''
        # remove padding + decompress
        return zlib.decompress(unpad(compressed))

class ArchiveEntry:
    '''[summary]
    '''
    @staticmethod
    def read(data):
        oft = 0
        path_sz, = struct.unpack('I', data[oft:oft+I_SZ])
        oft += I_SZ
        path = pathlib.Path(data[oft:oft+path_sz-1].decode())
        oft += path_sz
        uid = uuid.UUID(bytes=data[oft:oft+UID_SZ])
        oft += UID_SZ
        size, mode = struct.unpack('2I', data[oft:oft+2*I_SZ])
        oft += 2*I_SZ
        atime, mtime, ctime = struct.unpack('3d', data[oft:oft+3*d_SZ])
        oft += 3*d_SZ
        return ArchiveEntry(path, uid, size, mode, atime, mtime, ctime), oft

    def __init__(self, path, uid, size, mode, atime, mtime, ctime):
        self._path = path
        self._uid = uid
        self._size = size
        self._mode = mode
        self._atime = atime
        self._mtime = mtime
        self._ctime = ctime

    def __str__(self):
        return f"[{self._uid}|{self._path}]"

    @property
    def path(self):
        return self._path

    @property
    def uid(self):
        return self._uid

    @property
    def size(self):
        return self._size

    @property
    def mode(self):
        return self._mode

    @property
    def atime(self):
        return self._atime

    @property
    def mtime(self):
        return self._mtime

    @property
    def ctime(self):
        return self._ctime


class KeyStore:
    '''Represents the keyfile
    '''
    MAGIC = b'L0LKSTR\x00'

    def __init__(self, keyfile):
        self._path = keyfile
        self._shufflers = {}
        self._read()

    def _read(self):
        data = self._path.read_bytes()
        oft = 0
        magic = data[oft:oft+len(KeyStore.MAGIC)]
        if magic != KeyStore.MAGIC:
            raise RuntimeError(f"{self._path} is not a LOL KeyStore.")
        oft += len(KeyStore.MAGIC)
        shuffler_cnt, = struct.unpack('I', data[oft:oft+I_SZ])
        oft += I_SZ
        for _ in range(shuffler_cnt):
            shuffler, shuffler_sz = Shuffler.read(data[oft:])
            print(shuffler)
            oft += shuffler_sz
            self._shufflers[shuffler.uid] = shuffler

    def find(self, entry):
        return self._shufflers[entry.uid]

class Archive:
    '''Represents an archive
    '''
    MAGIC = b'L0LARCH\x00'
    SIZE_LIMIT = 1024*1024*10

    def __init__(self, archive, keyfile):
        self._path = archive
        self._entries = []
        self._keystore = KeyStore(keyfile)
        self._read()

    def _read(self):
        data = self._path.read_bytes()
        oft = 0
        magic = data[oft:oft+len(Archive.MAGIC)]
        if magic != Archive.MAGIC:
            raise RuntimeError(f"{self._path} is not a LOL Archive.")
        oft += len(Archive.MAGIC)
        entry_cnt, = struct.unpack('I', data[oft:oft+I_SZ])
        oft += I_SZ
        for _ in range(entry_cnt):
            entry, entry_sz = ArchiveEntry.read(data[oft:])
            print(entry)
            oft += entry_sz
            dsz, = struct.unpack('I', data[oft:oft+I_SZ])
            oft += I_SZ
            self._entries.append((entry, data[oft:oft+dsz]))
            oft += dsz

    def extract_to(self, output_dir):
        output_dir.mkdir(parents=True, exist_ok=True)
        for entry, data in self._entries:
            shuffler = self._keystore.find(entry)
            output_file = output_dir.joinpath(entry.path)
            print(f"extracting {output_file}...")
            output_file.parent.mkdir(parents=True, exist_ok=True)
            output_file.write_bytes(shuffler.unshuffle(data))

def parse_args():
    '''[summary]
    '''
    p = argparse.ArgumentParser(description="")
    p.add_argument('archive', type=pathlib.Path)
    p.add_argument('keyfile', type=pathlib.Path)
    p.add_argument('output_dir', type=pathlib.Path)
    return p.parse_args()

def app():
    '''[summary]
    '''
    args = parse_args()
    archive = Archive(args.archive, args.keyfile)
    archive.extract_to(args.output_dir)

if __name__ == "__main__":
    app()

