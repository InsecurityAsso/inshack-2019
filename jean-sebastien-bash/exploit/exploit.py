#!/bin/python3

"""
Exploit of the crypto challenge "Jean-SÃ©bastien Bash" from INS'hAck CTF 2019.
"""

from pwn import *
from binascii import hexlify
import os

# Change this
host='localhost'
port=2227
user='user'
keyfile='keys/id_rsa'

s = ssh(host=host, port=port, user=user, keyfile=keyfile)
shell = s.shell()

def read_all():
    """
    Read, print and return all lines of server, until an empty one is found.
    """
    line = 'blah'
    lines = []
    while line != b'\r\n':
        line = shell.readline()
        lines.append(line)
        print(line)

    return lines


def read_and_check_padding():
    """
    Read and print until empty line.
    Return if the padding is good.
    """
    lines = read_all()
    return b'What do you mean?!' not in lines[1]


def read_and_check_flag():
    """
    Read and print until empty line.
    Return if the flag was displayed
    """
    lines = read_all()

    for l in lines:
        if b'INSA{' in l:
            return True

    return False


def send_cmd(cmd_bytes):
    """
    Send an encrypted command (given as bytes) to the server.
    """
    line = b'/cmd ' + hexlify(cmd_bytes)
    shell.sendline(line)


def pad(cmd):
    """
    Pad a command
    """
    n = -(len(cmd) % 16) + 16
    return cmd + n * bytes([n])


def attack():
    """
    Execute the oracle padding attack.
    Return if the flag has been printed out.
    """
    # A list of one char bytes to modify one byte more easily
    C1 = [os.urandom(1)] * 16
    C2 = os.urandom(1) * 16
    
    # D(C_2)
    D = [b'\x00'] * 16

    # flush welcome message
    read_and_check_padding()

    i = 1

    for i in range(1, 17):
        found = False

        for j in range(1, i):
            C1[-j] = bytes([i ^ ord(D[-j])])

        for b in range(256):
            C1[-i] = bytes([b])
            send_cmd(b''.join(C1) + C2)
            if read_and_check_padding():
                found = True
                D[-i] = bytes([i ^ b])
                break

        if not found:
            print("Couldn't find the {}th byte of D(C_2)".format(i))
            return False

    # At this point we know D(C_2)

    cmds = [
        b' ; cat flag.txt',
        b' ;cat flag.txt',
        b';  cat flag.txt',
        b'; cat  flag.txt',
        b';cat   flag.txt']

    cmds += [c.replace(b'txt', b'*') for c in cmds]

    for cmd in cmds:
        C1 = b''.join(bytes([c ^ ord(d)]) for (c,d) in zip(pad(cmd), D))
        send_cmd(C1 + C2)
        if read_and_check_flag():
            return True

    print("Found D(C_2) but failed to print the flag.")
    return False


if __name__ == '__main__':
    if attack():
        print('SUCCESS')
    else:
        print('FAILURE')










