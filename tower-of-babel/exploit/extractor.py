#!/usr/bin/env python3
from io import BytesIO
from mmap import mmap, MAP_PRIVATE, PROT_READ
from struct import unpack, calcsize
from pathlib import Path
from argparse import ArgumentParser
from elftools.elf.elffile import ELFFile
from elftools.elf.structs import ELFStructs

ELF_SIG=b'\x7fELF'
FUNC_SIG=b'_6faed674'
VALID_KMOD=0x11264c40

def kmod_matches(mem):
    '''Extract kernel module binary from the memory dump
    '''
    func_sig_indices = []
    idx = -1
    # find all occurences of a char dev specific signature
    while True:
        idx = mem.find(FUNC_SIG, idx+1)
        if idx < 0:
            break
        func_sig_indices.append(idx)
    # find ELF signature preceding
    elf_sig_indices = set()
    for dev_idx in func_sig_indices:
        idx = mem.rfind(ELF_SIG, 0, dev_idx)
        elf_sig_indices.add(idx)
    # print info
    return sorted(list(elf_sig_indices))

def kmod_extract(mem, kmod_off):
    '''Extract kernel module from memory
    '''
    elf_structs = ELFStructs(little_endian=True, elfclass=64)
    elf_structs.create_basic_structs()
    hdr_struct = elf_structs.Elf_Ehdr
    hdr = hdr_struct.parse(mem[kmod_off:kmod_off+hdr_struct.sizeof()])
    #print(hdr)
    kmod_sz = hdr['e_shoff'] + hdr['e_shentsize'] * hdr['e_shnum']
    #print(f"extracting kmod starting at {hex(kmod_off)} (size={hex(kmod_sz)})")
    raw_kmod = BytesIO(mem[kmod_off:kmod_off+kmod_sz])
    #with open('tob.ko', 'wb') as ofp:
    #    ofp.write(mem[kmod_off:kmod_off+kmod_sz])
    return raw_kmod, ELFFile(raw_kmod)

def xor(key, value):
    '''[summary]
    '''
    data = bytearray(value)
    for k in range(len(data)):
        data[k] ^= key[k%len(key)]
    return bytes(data)

def decrypt_resources(resources, key):
    '''[summary]
    '''
    plaintext = []
    for resource_sz, resource in resources:
        plaintext.append(xor(key, resource))
    return plaintext

def resources_extract(kmod):
    '''Extract and decrypt resources from kernel module
    '''
    resources = []
    for section in kmod.iter_sections():
        if section.name == '.rodata':
            #print("parsing .rodata section...")
            #with open('rodata', 'wb') as ofp:
            #    ofp.write(section.data())
            rodata = section.data()
            offset = 32
            while offset < len(rodata):
                sz = unpack('i', rodata[offset:offset+4])[0]
                if sz != 0:
                    resources.append((sz, rodata[offset+4:offset+4+sz]))
                    offset += 512
                offset += 4
    # decode resources
    resources = decrypt_resources(resources[:-1], resources[-1][1])
    return resources

def flag_from(mem_dmp):
    '''Extract the flag from the memory dump
    '''
    with mem_dmp.open('rb') as fp:
        mem = mmap(fp.fileno(), 0, flags=MAP_PRIVATE, prot=PROT_READ)
        for kmod_off in kmod_matches(mem):
            if kmod_off == VALID_KMOD:
                raw_kmod, kmod = kmod_extract(mem, kmod_off)
                resources = resources_extract(kmod)
    for resource in resources:
        if b'INSA' in resource:
            return resource

def parse_args():
    '''Parse commandline arguments
    '''
    p = ArgumentParser(description="")
    p.add_argument('mem_dmp', type=Path)
    return p.parse_args()

def app():
    '''Application entry point
    '''
    args = parse_args()
    flag = flag_from(args.mem_dmp)
    if not flag:
        print("flag not found.")
    print(f"INSA{flag.decode().strip().split('INSA')[1]}")

if __name__ == "__main__":
    app()
