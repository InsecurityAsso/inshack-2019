from enum import Enum, Flag
from struct import unpack, calcsize
from ddfs.crypto import xor, decrypt_buf, encrypt_buf

class Record:
    '''[summary]
    '''
    SZ = 256
    HASH_SZ = 32
    NAME_SZ = 176
    IV_SZ = 16
    SEAL = b'-!-RECORDSEAL-!-'
    SEAL_SZ = 16
    BLOCK_SZ = 16

    class Type(Enum):
        '''[summary]
        '''
        NONE = 0
        REGULAR = 1
        DIRECTORY = 2

    class Flags(Flag):
        '''[summary]
        '''
        NONE = 0
        ENCRYPTED = 1
        USED = 2

    def __init__(self, data):
        '''[summary]
        '''
        fmt = f'{self.HASH_SZ}s{self.NAME_SZ}s{self.IV_SZ}s{self.SEAL_SZ}s4i'
        # pre-unpacking sanity checks
        if len(data) != self.SZ:
            raise RuntimeError(f"input data size differs from expected record size ({self.SZ}).")
        if calcsize(fmt) != self.SZ:
            raise RuntimeError(f"unpack format size differs from expected record size ({self.SZ}).")
        record = unpack(fmt, data)
        # initialize members
        self._hash = record[0]
        self._name = record[1]
        self._iv = record[2]
        self._seal = record[3]
        self._type = Record.Type(record[4])
        self._flags = Record.Flags(record[5])

    @property
    def type(self):
        return self._type

    @property
    def flags(self):
        return self._flags

    @property
    def iv(self):
        return self._iv.hex()

    @property
    def hash(self):
        return self._hash.hex()

    @property
    def used(self):
        return bool(self._flags & self.Flags.USED)

    @property
    def encrypted(self):
        return bool(self._flags & self.Flags.ENCRYPTED)

    @property
    def name(self):
        return self._name[:self._name.index(b'\x00')].decode()

    def __str__(self):
        '''[summary]
        '''
        return f"{self.hash}|{self.name}|{self.iv}|{self.type}|{self.flags}"

    def decrypt(self, key):
        '''[summary]
        '''
        if self.encrypted:
            seal = decrypt_buf(self._iv, key, self._seal)
            if seal != self.SEAL:
                raise RuntimeError("Decrypted seal does not match initial seal.")
            self._name = decrypt_buf(self._iv, key, self._name)
            self._flags &= ~self.Flags.ENCRYPTED
        return not self.encrypted

    def decrypt_fbuf(self, key, data):
        '''[summary]
        '''
        buflen = len(data)
        remain = buflen % self.BLOCK_SZ
        plaintext = decrypt_buf(self._iv, key, data[:buflen - remain])
        plaintext += xor(data[buflen - remain:], encrypt_buf(self._iv, key, self._iv))
        return plaintext
